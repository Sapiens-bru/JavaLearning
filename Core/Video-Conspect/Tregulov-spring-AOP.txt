AOP - Aspect Orienting Programing
Парадигма программирования основанная на разделении основного и служебного функционала. Служебный функционал записывается в Aspect классы. 
Служебный функционал называют сквозной логикой, а основной функционал бизнес-логикой. Пример сквозной логики - авторизация, логгирование, работа с транзакциями
Паттерн проектирования для реализации такого подхода называется Proxy
При проксировании создается отдельный класс(AOP Proxt) который обеспечивает работу c основным классом и добавляет логику Аспект классов.
Вместо 
Основной класс <-> Вызывающий код
Используется
Основной класс <-> AOP Proxy <-> Вызывающий код

Плюсы AOP
1) Сквозной функционал сосредоточен в одном или небольшом количестве Аспект-классов и его легко изменять
2) Легче добавть новые сквозные работы для основного кода или добавить имеющиеся сквозные работы к новым классам
3) Бизнес-код избавляется от сквозного кода, работать с ним становится проще
Минус AOP
Небольшое замедление при работе AOP Proxy

Спринг по-умолчанию использует AOP, он встроен в фреймворк. Существует отдельный от спринга фреймворк AspectJ более сложный и мощный.

@EnableAspectJAutoProxy
Аннотация к @Configuration позволяет использовать AOP совместно с контенером.

@Aspect 
Аннотация к @Component отмечает класс как Aspect-класс для сквозной логики. Аннотация является частью AspectJ Weaver который придется скачать в виде jar файла или добавить а зависимости мавен.

Метод внутри Аспект-Класса называется Advice
Метод бизнес-логики к которому прикрепляются Advice в рамках обсуждения AOP называются также target-методы
Существуют разные типы Advice
Before - Выполняется до метода
After/After finally - Выполняется после метода при любом его исходе
After returning - Выполняется после метода если в методе не возникла ошибка
After throwing - Выполняется после метода если было выброшено исключение
Around - Выполняется до и после метода

Пример синтаксиса:
@Before("execution (void getBook())")
То что в кавычках называется Pointcut , это выражение которое определяет когда будет выполнен Advice. Выражение описывается на языке AspectJ Pintcut expression language. 
Шаблон execution("S1 S2 S3 S4(S5) S6")
S1 - не обязательный, модификатор доступа метода
S2 - обязательный, тип возвращаемого параметра
S3 - не обязательный, указание на класс для поиска метода
S4 - обязательный, имя метода
S5 - обязательный, параметры метода
S6 - не обязательный, описание исключений метода

Для Pointcat есть Wilcard для задания наименований методов при помощи * , например get* подходит под любой метод начинающийся на get
Звездочку можно использовать в других местах шаблона. Например если щаблон возвращаемого типа заменить на * , он подойдет под любой тип возвращаемого значения
@Before("execution (* aop.library.get*())")
Для Pointcut с параметрами метода мы указываем только тип параметра, но не его имя, при этом * в параметрах означает один параметр метода
@Before("execution (* *(*,*))") - любой метод с двумя любыми параметрами
(..) означает любое количество любых параметров
@Before("execution (void getBook(aop.Book,..))") Если тип параметра не входит в стандартные библиотеки, а является типом нашего класса мы указываем его вместе с именеи пакета. В данном шаблоне первый параметр должен быть типа Book а затем может быть любое количество любых параметров.

Аннотация @Pointcut позволяет объявить метод, имя которого будет использоваться как ссылка на выражение pointcut
Например:
@Pointcut("excectution(* get*(..))")
private void allGetMetod(){}
Использование
@Before("allGetMetod()")
Если @Pointcut объявить не private тогда его можно использовать в выражениях в других аспект-классах, для этого придется прописать полное имя

Описание Pointcat можно соединять условиями || && !

При объявлении нескольких Адвайсов подходящих методу они вызываются в произвольном порядке, настроить порядок можно распределив Адвайсы по разным аспектам и использовав аннотацию @Order(int i) Это дополнительная аннотация к @Aspect . Чем меньше порядковый номер, тем раньше вызывается Аспект и его Адвайсы. Указать разным аспектам один порядковый номер можно, тогда их порядок опять же будет не гарантирован

Для Advice методов есть способ определения с параметром
@Before("allGetMetod()")
public void beforeAllGetMetod(JointPoint jp)
Параметр типа JointPoint содержит информацию о методе к которому присоединяется Адвайс. 
MethodSignature ms = (MetodSignature)jp.getSignature(); - получение сигнатуры метода, отсюда можно получить как полное описание, так и части описания, например имя метода, типы параметров, тип возвращаемого значения
Object[] args = jp.getArgs() Получает массив объектов со значениями параметров.

@AfterReturning - Благодаря срабатыванию после выполнения таргет-метода, в Адвайсе с такой аннотацией возможно получить возвращаемое значение метода. Если это значение изменить в Адвайсе - возвращаемое значение таргет-метода также поменяется
Синтаксис:
@AfterReturning(pointcut = "* getStudents()", returning = "students")
public void afterReturningGetStudents(List<Student> students)
или
public void afterReturningStudents(JointPoint jp, List<Student> students)

@AfterThrowing - Срабатывает при исключении в таргет-методе и имеет доступ к этому исключению, но не может его обрабатывать
Синтаксис:
@AfterThrowing(pointcut = "* getStudents()", throwing = "excp")
public void afterThrowingGetStudents(Throwable excp)