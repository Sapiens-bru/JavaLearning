Конспект по сложным главам книги On Java 8


Коллекции
Базовые типы коллекций : List , Set, Queue, Map

Set хранит уникальные значения
Map - ассоциативный массив. То есть хранит одни объекты в связи с дургими объектами

Коллекции java автоматически изменяют размер, в отличии от array

До java 5 была проблема - коллекции позволяли вставлять данные некорректных типов, это не отслеживалось компилятором и ошибка выявлялась в рантайме. 

class Apple {
	private static long counter;
	privati final long id = counter++;
	public long id() { return id; }
}
class Orange{}

....

psvm{
ArrayList apples = new ArrayList();
apples.add(new Apple());
apples.add(new Orange());
for (Object apple : apples){
	(Apple) apple.id(); // < ---  Ошибка в рантайме
}
}

ArrayList содержит список Объектов и в него можно записать любые объекты. 
С появлением дженериков появилась возможность явным образом указывать тип хранимых объектов

ArrayList<Apple> apples = new ArrayList<Apple>();
....
for(Apple apple : apples){
	apple.id()
}

Теперь при добавлении объекта не того типа получим ошибку во время компиляции. Кроме того каст от объекта в также не нужен, мы можем перебирать объекты выбранного типа

Как видим конструкция достаточно сложная и название типа данных в ней встречается дважды. Типы данных могут быть достаточно длинными. Чтобы не писать их дважды в Java 7 сделан оператор <> - даймонд (алмаз) , означающий что тип дженерика выводится из левой части выражения

ArrayList<Apple> apples = new ArrayList<>();

В java идея коллекции содержащей объекты делится на два концепта.
Коллекции (Set, List, Queue)
Соответствие (Map)

Коллекция это последовательность индивидуальных элементов подчиняющаяся одному или нескольким правилам. Список (List) должен содержать элементы в порядке их вставки , Set не может содержать дубли, Очередь (Queue) выстраивает элементы в заданном порядке, обычно в порядке вставки
Соответствие это группа пар объектов ключ-значение, поиск значений выполняется по ключу. ArrayList ищет объект по номеру, а map ищет объект по другому объекту. Иногда соответствия называют словарями, потому что поиск объекта по объекту похож на поиск значения слова в словаре.

Хотя это не всегда возможно, но в идеале код нужно стараться писать так чтобы обращатся к коллекциям по их интерфейсам и задавать их точный тип только в момент создания

List<Apple> apples = new ArrayList<>(); 

Мы используем апкаст до интерфейса чтобы в случае необходимости можно было легко поменять реализацию, не меняя остальной код

List<Apple> apples = new LinkedList<>();

Получается мы создаем объект конкретного типа и тут же проводим апкаст до интерфейса, тем самым лишаемся некоторых возможностей конкретного класса, но получаем возможность гибкой замены
Еще более глобальный интерфейс Collection представляет саму идею "последовательности", способа хранения группы объектов

Collection<Integer> c = new ArrayList<>();

Интересный момент с методом add() , для разных реализаций Collection поведение метода разное, поэтому в документации не указано "добавляет элемент" а указано "позволяет убедится что в коллекции имеется элемент", то есть он там либо уже был, либо будет добавлен, как это сделает Set.
Collection как и ее потомки может быть использована в синтаксисе for-in

В коллекциях есть методы группового добавления. У класса Arrays есть метод asList который возвращает List с урезанной реализацией (не изменяемого размера)
Чтобы преобразовать получаемый из asList список в более полноценный нужно воспользоваться методом addAll из интерфейса Collection
Либо использовать статический метод addAll из объекта Collections , он может добавлять к коллекции массив / варАрг в одно действие
ЗАМЕТКА!! не путать класс Collections и интерфейс Collection . Первый является простым набором статических методов применимых к коллекциям, второй позволяет реализовывать разные коллекции.
Также конструкторы классов реализующих Collection умеют принимать объект коллекции в качестве инициализирующего значения, но метод Collections.addAll работает существенно быстрее

Коллекции могут быть напечатаны (sout) без вызова метода .toString(), который необходим для печати массива. Поведение при выводе на печать задано в дефолтных методах toString , определенных в каждой реализации коллекции.

HashSet хранит элементы не в натуральном порядке, а согласно хэш функции. Это позволяет получать элементы наиболее быстрым способом.
TreeSet хранит элементы в порядке сравнения(маленькие в начале, большие в конце)
LinkedHashSet хранит элементы в порядке их добавления

Аналогично HashMap хранит пары в порядке хэшей, TreeMap в порядке сортировки ключей, LinkedHashMap в порядке вставки

Интерфейс Collection наследуется от интерфейса Iterable , который имеет метод iterator() который в свою очередь возвращает интерфейс Iterator . Объекты реализующие этот интерфейс реализованы при помощи внутренних классов в классах реализующих коллекции. Iterator это наиболее общий способ обхода колекций. Получение Итератора позиционирует его на первом элементе коллекции. Проверка hasNext служит для определения возможности перемещения по коллекции. Метод next() получает следующее значение, метод remove() удаляет текущее, метод forEachRemaining позволяет выполнить Consumer для каждого элемента итератора начиная с текущего.
Итератор - самый общий способ работы с коллекциями

Более мощная, но и более специфичная версия итератора есть в интерфейсе List. ListIterator позволяет двигатся по списку в двух направлениях(hasPrevious(),previousIndex(),previous()) и имеет метод set() изменяющий текущий элемент. ListIterator можно позиционировать в середину коллекции вызывая listIterator(n)

LinkedList более эффективен при вставке в середину списка чем ArrayList но менее эффективен в операциях случайного доступа

LinkedList имеет методы для использования его как стека (stack) или двунаправленной очереди (deque)
getFirst() и element() идентичны, они возвращают первый элемент списка. peak() немного отличается, если список пуст peak() вернёт null а не исключение
removeFirst и remove() также идентичны, они удаляют и возвращают первый элемент списка. poll() делает то же самое но для пустого списка возвращает null
addFirst() добавляет элемент в начало списка
offer() , add() , addLast() идентичны, они добавляют элемент в конец списка
removeLast() возвращает и удаляет элемент в конце списка

Методы element,poll итд в LinkedList унаследованы от интерфейса Queue 

В java изначально есть класс Stack реализующий стек, но он был плохо спроектирован и в Java 6 предложен к замене на класс ArrayDeque , реализующий  интерфейс Deque 
Классический стек может быть реализован например так
public class Stack<T> {
private Deque<T> storage = new ArrayDeque<>();
public void push(T v) { storage.push(v); }
public T peek() { return storage.peek(); }
public T pop() { return storage.pop(); }
public boolean isEmpty() { return storage.isEmpty(); }
@Override public String toString() {
return storage.toString();
}
}
Внимание на тот факт что Stack не является потомком ArrayDeque и потому не наследует все его методы. Здесь применена композиция, а не наследование. Взяли только нужные методы от ArrayDeque и явным образом вызвали их для Stack
Также можно обратить внимание на дженерики. Дженерик говорит компилятору что будет использован параметризованный тип, то есть тип станет точно известен когда класс будет использован. Это позволяет определить один класс для всех типов данных.

Set - Множество. Хранит только уникальные значения. Наиболее употребимым использование Set бывает для определения содержится какой-то элемент во множестве или нет. Поэтому наиболее часто употребимой реализацией интерфейса Set будет HashSet оптимизированая для быстрого поиска
HashSet хранит информацию в порядке хэшей, для объекта типа Integer с недавнего времени порядок хэшей совпадает с порядком хранимых чисел, что приводит к хранению в HashSet в отсортированном виде, но надеятся на такое поведение не нужно.
Для хранения в отсортированном виде стоит использовать TreeSet
Для коллекций типа TreeX при создании можно передать Comparator который будет использоватся для сортировки элементов. Например TreeSet сортирует объекты типа String в алфавитном порядке, но при этом большие и маленькие буквы находятся в разных группах. Для сортировки в алфавитном порядке без учета регистра можно использовать стандартный омпаратор предоставляемый объектом String

Set<String> words = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);

Примитивы нельзя хранить в коллекциях, при попытке помещения они автоматически упаковываются в соответствующие объекты

Map может вернуть Set от ключей, Collection значений или Set пар ключ-значение

Очередь (Queue) это FIFO коллекция. Очереди особенно важны в многопоточном программировании потому что они безопасно передают объекты между потоками
Примером реализации очереди может служить ранее рассмотренный LinkedList
У очереди есть свои методы обеспечивающие полную функциональность интерфейса без обращения к методам Collection от которых она унаследована

Реализация PriorityQueue выдает объкт сортированный в порядке указанном компаратором. То есть алгоритм FIFO заменяется на другой. Мы получаем не тот элемент который положили в очередь первым, а тот что имеет наибольший приоритет.
Например код ниже получает очередь из строк-букв в обратном алфавитном порядке

String fact = "EDUCATION SHOULD ESCHEW OBFUSCATION";
List<String> strings = Arrays.asList(fact.split(""));
PriorityQueue<String> stringPQ = new PriorityQueue<>(strings.size(), Collections.reverseOrder());
stringPQ.addAll(strings);

Классы обёртки и String уже имеют встроенные средства позволяющие их упорядочивать. Если нужно строить упорядоченную очередь из других объектов тогда в PriorityQueue нужно передавать компаратор, либо обеспечивать такую функциональность внутри объектов

В Java есть класс AbstractCollection который реализует интерфейс Collection и служит для наследования при создании своих коллекций без лишнего дублирования кода
Если есть свой класс который должен вести себя как коллекция, но он уже унаследован от другого калсса - его невозможно унаследовать от AbstractCollection , тогда можно реализовать в своем классе интерфейс Collection , но там довольно много методов, обычно в полном составе не нужных. Для простого обхода некоторого класса-коллекции достаточно Итератора. В таком случае можно создать внутри своего класса метод iterator() и вернуть объект Iterator реализованный внутренним , возможно абстрактным классом.

Синтаксис for-in работает с массивами и с любыми объектами Collection. Причина по которой это возможно в том что Collection реализует интерфейс Iterable который создает итератор. Любой собственный класс реализующий Iterable также получает доступ к синтаксису For-in

Интерфейс Map не реализует Iterable
В интерфейсе Map есть вложенный интерфейс Entry который представляет собой пару Ключ-Значение
Есть метод entrySet() который возвращает сет состоящий из Entry
Совместное использование позволяет обходить Map в цикле For-in

for(Map.Entry entry: System.getenv().entrySet()) {

Метод Arrays.asList создаёт список в котором физическое храненение элементов осущетвляется в том же массиве что был передан в качестве параметра. Это приводит к тому что при изменении полученного List изменяется и изначальный массив.
Если нужно получить независимый List его нужно получать как отдельную коллекцию с передачей туда результатов Arrays.asList в конструктор или метод addAll , это создаст новый объект в котором будут хранится ссылки на изначальный массив

Немного о паттерне разработки Adapter
Возможна ситуация в которой нам одновременно понадобятся несколько реализаций одного и того

