Конспект по сложным главам книги On Java 8


Коллекции
Базовые типы коллекций : List , Set, Queue, Map

Set хранит уникальные значения
Map - ассоциативный массив. То есть хранит одни объекты в связи с дургими объектами

Коллекции java автоматически изменяют размер, в отличии от array

До java 5 была проблема - коллекции позволяли вставлять данные некорректных типов, это не отслеживалось компилятором и ошибка выявлялась в рантайме. 

class Apple {
	private static long counter;
	privati final long id = counter++;
	public long id() { return id; }
}
class Orange{}

....

psvm{
ArrayList apples = new ArrayList();
apples.add(new Apple());
apples.add(new Orange());
for (Object apple : apples){
	(Apple) apple.id(); // < ---  Ошибка в рантайме
}
}

ArrayList содержит список Объектов и в него можно записать любые объекты. 
С появлением дженериков появилась возможность явным образом указывать тип хранимых объектов

ArrayList<Apple> apples = new ArrayList<Apple>();
....
for(Apple apple : apples){
	apple.id()
}

Теперь при добавлении объекта не того типа получим ошибку во время компиляции. Кроме того каст от объекта в также не нужен, мы можем перебирать объекты выбранного типа

Как видим конструкция достаточно сложная и название типа данных в ней встречается дважды. Типы данных могут быть достаточно длинными. Чтобы не писать их дважды в Java 7 сделан оператор <> - даймонд (алмаз) , означающий что тип дженерика выводится из левой части выражения

ArrayList<Apple> apples = new ArrayList<>();

В java идея коллекции содержащей объекты делится на два концепта.
Коллекции (Set, List, Queue)
Соответствие (Map)

Коллекция это последовательность индивидуальных элементов подчиняющаяся одному или нескольким правилам. Список (List) должен содержать элементы в порядке их вставки , Set не может содержать дубли, Очередь (Queue) выстраивает элементы в заданном порядке, обычно в порядке вставки
Соответствие это группа пар объектов ключ-значение, поиск значений выполняется по ключу. ArrayList ищет объект по номеру, а map ищет объект по другому объекту. Иногда соответствия называют словарями, потому что поиск объекта по объекту похож на поиск значения слова в словаре.

Хотя это не всегда возможно, но в идеале код нужно стараться писать так чтобы обращатся к коллекциям по их интерфейсам и задавать их точный тип только в момент создания

List<Apple> apples = new ArrayList<>(); 

Мы используем апкаст до интерфейса чтобы в случае необходимости можно было легко поменять реализацию, не меняя остальной код

List<Apple> apples = new LinkedList<>();

Получается мы создаем объект конкретного типа и тут же проводим апкаст до интерфейса, тем самым лишаемся некоторых возможностей конкретного класса, но получаем возможность гибкой замены
Еще более глобальный интерфейс Collection представляет саму идею "последовательности", способа хранения группы объектов

Collection<Integer> c = new ArrayList<>();

Интересный момент с методом add() , для разных реализаций Collection поведение метода разное, поэтому в документации не указано "добавляет элемент" а указано "позволяет убедится что в коллекции имеется элемент", то есть он там либо уже был, либо будет добавлен, как это сделает Set.
Collection как и ее потомки может быть использована в синтаксисе for-in

В коллекциях есть методы группового добавления. У класса Arrays есть метод asList который возвращает List с урезанной реализацией (не изменяемого размера)
Чтобы преобразовать получаемый из asList список в более полноценный нужно воспользоваться методом addAll из интерфейса Collection
Либо использовать статический метод addAll из объекта Collections , он может добавлять к коллекции массив / варАрг в одно действие
ЗАМЕТКА!! не путать класс Collections и интерфейс Collection . Первый является простым набором статических методов применимых к коллекциям, второй позволяет реализовывать разные коллекции.
Также конструкторы классов реализующих Collection умеют принимать объект коллекции в качестве инициализирующего значения, но метод Collections.addAll работает существенно быстрее

Коллекции могут быть напечатаны (sout) без вызова метода .toString(), который необходим для печати массива. Поведение при выводе на печать задано в дефолтных методах toString , определенных в каждой реализации коллекции.

HashSet хранит элементы не в натуральном порядке, а согласно хэш функции. Это позволяет получать элементы наиболее быстрым способом.
TreeSet хранит элементы в порядке сравнения(маленькие в начале, большие в конце)
LinkedHashSet хранит элементы в порядке их добавления

Аналогично HashMap хранит пары в порядке хэшей, TreeMap в порядке сортировки ключей, LinkedHashMap в порядке вставки

Интерфейс Collection наследуется от интерфейса Iterable , который имеет метод iterator() который в свою очередь возвращает интерфейс Iterator . Объекты реализующие этот интерфейс реализованы при помощи внутренних классов в классах реализующих коллекции. Iterator это наиболее общий способ обхода колекций. Получение Итератора позиционирует его на первом элементе коллекции. Проверка hasNext служит для определения возможности перемещения по коллекции. Метод next() получает следующее значение, метод remove() удаляет текущее, метод forEachRemaining позволяет выполнить Consumer для каждого элемента итератора начиная с текущего.
Итератор - самый общий способ работы с коллекциями

Более мощная, но и более специфичная версия итератора есть в интерфейсе List. ListIterator позволяет двигатся по списку в двух направлениях(hasPrevious(),previousIndex(),previous()) и имеет метод set() изменяющий текущий элемент. ListIterator можно позиционировать в середину коллекции вызывая listIterator(n)

LinkedList более эффективен при вставке в середину списка чем ArrayList но менее эффективен в операциях случайного доступа

LinkedList имеет методы для использования его как стека (stack) или двунаправленной очереди (deque)
getFirst() и element() идентичны, они возвращают первый элемент списка. peak() немного отличается, если список пуст peak() вернёт null а не исключение
removeFirst и remove() также идентичны, они удаляют и возвращают первый элемент списка. poll() делает то же самое но для пустого списка возвращает null
addFirst() добавляет элемент в начало списка
offer() , add() , addLast() идентичны, они добавляют элемент в конец списка
removeLast() возвращает и удаляет элемент в конце списка

Методы element,poll итд в LinkedList унаследованы от интерфейса Queue 

В java изначально есть класс Stack реализующий стек, но он был плохо спроектирован и в Java 6 предложен к замене на класс ArrayDeque , реализующий  интерфейс Deque 
Классический стек может быть реализован например так
public class Stack<T> {
private Deque<T> storage = new ArrayDeque<>();
public void push(T v) { storage.push(v); }
public T peek() { return storage.peek(); }
public T pop() { return storage.pop(); }
public boolean isEmpty() { return storage.isEmpty(); }
@Override public String toString() {
return storage.toString();
}
}
Внимание на тот факт что Stack не является потомком ArrayDeque и потому не наследует все его методы. Здесь применена композиция, а не наследование. Взяли только нужные методы от ArrayDeque и явным образом вызвали их для Stack
Также можно обратить внимание на дженерики. Дженерик говорит компилятору что будет использован параметризованный тип, то есть тип станет точно известен когда класс будет использован. Это позволяет определить один класс для всех типов данных.

Set - Множество. Хранит только уникальные значения. Наиболее употребимым использование Set бывает для определения содержится какой-то элемент во множестве или нет. Поэтому наиболее часто употребимой реализацией интерфейса Set будет HashSet оптимизированая для быстрого поиска
